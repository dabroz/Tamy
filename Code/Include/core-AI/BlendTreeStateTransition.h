/// @file   core-AI/BlendTreeStateTransition.h
/// @brief  a blend tree state machine transition interface
#pragma once

#include "core\ReflectionObject.h"
#include "core\RuntimeData.h"
#include "core\Transform.h"


/////////////////////////////////////////////////////////////////////////////////////////

class BlendTreeNode;
class BlendTreeStateMachine;
class BlendTreePlayer;
class BlendTreeTransitionEffect;
class BlendTreeTransitionTrigger;
class BlendTreeSyncProfile;
class BlendTreeNodeSyncProfile;

/////////////////////////////////////////////////////////////////////////////////////////

/**
 * A blend tree state machine transition interface.
 */
class BlendTreeStateTransition : public ReflectionObject
{
   DECLARE_ALLOCATOR( BlendTreeStateTransition, AM_DEFAULT );
   DECLARE_CLASS();

public:
   std::string                      m_name;

   BlendTreeTransitionEffect*       m_effect;
   BlendTreeTransitionTrigger*      m_transitionTrigger;

   BlendTreeNode*                   m_startState;
   BlendTreeNode*                   m_endState;

   TRuntimeVar< Transform* >        m_generatedPose;
   TRuntimeVar< Transform >         m_accumulatedMotion;

public:
   /**
    * Constructor.
    *
    * @param name
    */
   BlendTreeStateTransition( const char* name = "Transition" );
   ~BlendTreeStateTransition();

   /**
    * Sets the states this transition connects.
    *
    * @param startState
    * @param endState
    */
   void setConnection( BlendTreeNode* startState, BlendTreeNode* endState );

   /**
    * Sets an effect instance this transition should use.
    *
    * The transition takes ownership of the effect.
    *
    * @param effect
    */
   void setEffect( BlendTreeTransitionEffect* effect );

   /**
    * Sets an object that will decide when the transition can be triggered.
    *
    * The transition takes ownership of the trigger.
    *
    * @param transitionTrigger
    */
   void setTransitionTrigger( BlendTreeTransitionTrigger* transitionTrigger );

   /**
    * Initializes the state transition's runtime data layout.
    *
    * @param player
    */
   void initializeLayout( BlendTreePlayer* player ) const;

   /**
    * Deinitializes the state transition's runtime data layout.
    *
    * @param player
    */
   void deinitializeLayout( BlendTreePlayer* player ) const;

   /**
    * Activates the transition. It will activate the end state while keeping the start state active.
    *
    * @param player
    * @param hostMachine
    */
   void activate( BlendTreePlayer* player, const BlendTreeStateMachine* hostMachine ) const;
    
   /**
    * Deactivates the transition. It will deactivate the start state.
    *
    * @param player
    * @param hostMachine
    */
   void deactivate( BlendTreePlayer* player, const BlendTreeStateMachine* hostMachine ) const;

   /**
    * Interrupts the transition when it's active and has both nodes activated.
    * It will deactivate both states.
    *
    * @param player
    * @param hostMachine
    */
   void interrupt( BlendTreePlayer* player, const BlendTreeStateMachine* hostMachine ) const;

   /**
    * Checks if this transition can be activated.
    *
    * @param player
    */
   bool testActivation( BlendTreePlayer* player ) const;

   /**
    * Updates the transition.
    *
    * @param player
    * @param timeDelta     upon return this value will be reduced by the amount the transition required this frame
    * @return              'true' if the transition has ended, 'false' if it's still in progress
    */
   bool update( BlendTreePlayer* player, float timeDelta ) const;

   /**
    * Returns the pose generated by this transition.
    *
    * @param player
    */
   Transform* getGeneratedPose( BlendTreePlayer* player ) const;

   /**
    * Returns the motion accumulated during the transition.
    *
    * @param player
    */
   Transform& getAccumulatedMotion( BlendTreePlayer* player ) const;
};

/////////////////////////////////////////////////////////////////////////////////////////
